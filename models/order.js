/**
Copyright 2017 ToManage

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

@author    ToManage SAS <contact@tomanage.fr>
@copyright 2014-2017 ToManage SAS
@license   http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0
International Registered Trademark & Property of ToManage SAS
*/



"use strict";

/**
 * Module dependencies.
 */
var mongoose = require('mongoose'),
    Schema = mongoose.Schema,
    ObjectId = mongoose.Schema.Types.ObjectId,
    timestamps = require('mongoose-timestamp'),
    async = require('async'),
    _ = require('lodash');

var DataTable = require('mongoose-datatable');

DataTable.configure({
    verbose: false,
    debug: false
});
mongoose.plugin(DataTable.init);

var Dict = INCLUDE('dict');

var setPrice = MODULE('utils').setPrice;
var setDate = MODULE('utils').setDate;

var options = {
    collection: 'Orders',
    discriminatorKey: '_type',
    toObject: {
        virtuals: true
    },
    toJSON: {
        virtuals: true
    }
};


const baseSchema = new Schema({
    forSales: {
        type: Boolean,
        default: true
    },
    isremoved: Boolean,
    ref: {
        type: String,
        index: true
    },
    ID: {
        type: Number
    },
    /*title: {//For internal use only
        ref: String,
        autoGenerated: {
            type: Boolean,
            default: false
        } //For automatic process generated deliveries
    },*/
    currency: {
        _id: {
            type: String,
            ref: 'currency',
            default: ''
        },
        rate: {
            type: Number,
            default: 1
        } // changed default to '0' for catching errors
    },

    Status: {
        type: String,
        default: 'DRAFT'
    },
    cond_reglement_code: {
        type: String,
        default: 'RECEP'
    },
    mode_reglement_code: {
        type: String,
        default: 'TIP'
    },
    bank_reglement: {
        type: ObjectId,
        ref: 'bank'
    },
    //availability_code: {type: String, default: 'AV_NOW'},
    type: {
        type: String,
        default: 'SRC_COMM'
    },
    supplier: {
        type: Schema.Types.ObjectId,
        ref: 'Customers',
        require: true
    },
    contacts: [{
        type: Schema.Types.ObjectId,
        ref: 'Customers'
    }],
    ref_client: {
        type: String,
        default: ""
    },
    datec: {
        type: Date,
        default: Date.now,
        set: setDate
    },
    datedl: {
        type: Date,
        default: Date.now,
        set: setDate
    },
    notes: [{
        title: String,
        note: String,
        public: {
            type: Boolean,
            default: false
        },
        edit: {
            type: Boolean,
            default: false
        }
    }],
    discount: {
        escompte: {
            percent: {
                type: Number,
                default: 0
            },
            value: {
                type: Number,
                default: 0,
                set: setPrice
            } // total remise globale
        },
        discount: {
            percent: {
                type: Number,
                default: 0
            }, //discount
            value: {
                type: Number,
                default: 0,
                set: setPrice
            } // total remise globale
        }
    },
    total_ht: {
        type: Number,
        default: 0,
        set: setPrice
    },
    total_taxes: [{
        _id: false,
        taxeId: {
            type: Schema.Types.ObjectId,
            ref: 'taxes'
        },
        value: {
            type: Number,
            default: 0
        }
    }],
    total_ttc: {
        type: Number,
        default: 0,
        set: setPrice
    },
    total_paid: {
        type: Number,
        default: 0,
        set: setPrice
    },
    shipping: {
        total_ht: {
            type: Number,
            default: 0,
            set: setPrice
        },
        total_taxes: [{
            _id: false,
            taxeId: {
                type: Schema.Types.ObjectId,
                ref: 'taxes'
            },
            value: {
                type: Number,
                default: 0
            }
        }],
        /*total_ttc: {
            type: Number,
            default: 0
        }*/
    },
    createdBy: {
        type: ObjectId,
        ref: 'Users'
    },
    editedBy: {
        type: ObjectId,
        ref: 'Users'
    },
    salesPerson: {
        type: ObjectId,
        ref: 'Employees'
    }, //commercial_id
    salesTeam: {
        type: ObjectId,
        ref: 'Department'
    },
    entity: String,
    optional: Schema.Types.Mixed,
    order: {
        type: ObjectId,
        ref: 'order'
    }, //Link to OrderRow
    delivery_mode: {
        type: String,
        default: "Comptoir"
    },
    billing: {
        type: Schema.Types.ObjectId,
        ref: 'Customers'
    },
    //costList: { type: ObjectId, ref: 'priceList', default: null }, //Not used
    //priceList: { type: ObjectId, ref: 'priceList', default: null },
    address: {
        name: {
            type: String,
            default: ''
        },
        street: {
            type: String,
            default: ''
        },
        city: {
            type: String,
            default: ''
        },
        state: {
            type: String,
            default: ''
        },
        zip: {
            type: String,
            default: ''
        },
        country: {
            type: String,
            ref: 'countries',
            default: 'FR'
        },
        contact: {
            name: {
                type: String,
                default: ''
            },
            phone: {
                type: String,
                set: MODULE('utils').setPhone,
                default: ''
            },
            mobile: {
                type: String,
                set: MODULE('utils').setPhone,
                default: ''
            },
            fax: {
                type: String,
                set: MODULE('utils').setPhone,
                default: ''
            },
            email: {
                type: String,
                lowercase: true,
                trim: true,
                index: true
            }
        }
    },
    shippingAddress: {
        _id: {
            type: ObjectId,
            default: null
        },
        name: {
            type: String,
            default: ''
        },
        street: {
            type: String,
            default: ''
        },
        city: {
            type: String,
            default: ''
        },
        state: {
            type: String,
            default: ''
        },
        zip: {
            type: String,
            default: ''
        },
        country: {
            type: String,
            ref: 'countries',
            default: 'FR'
        },
        contact: {
            name: {
                type: String,
                default: ''
            },
            phone: {
                type: String,
                set: MODULE('utils').setPhone,
                default: ''
            },
            mobile: {
                type: String,
                set: MODULE('utils').setPhone,
                default: ''
            },
            fax: {
                type: String,
                set: MODULE('utils').setPhone,
                default: ''
            },
            email: {
                type: String,
                lowercase: true,
                trim: true,
                index: true
            }
        }
    },
    /*bl: [{
        label: String,
        name: String,
        contact: String,
        address: String,
        zip: String,
        town: String,
        products: [{
            id: Schema.Types.ObjectId,
            name: String,
            qty: {
                type: Number,
                default: 0
            } // QTY Order
        }],
        shipping: {
            id: String,
            label: String,
            address: Boolean,
            total_ht: {
                type: Number,
                default: 0
            }
        }
    }],*/
    weight: {
        type: Number,
        default: 0
    }, // Poids total
    /*lines: [{
        _id: false,
        //pu: {type: Number, default: 0},
        type: { type: String, default: 'product' }, //Used for subtotal
        refProductSupplier: String, //Only for an order Supplier
        qty: { type: Number, default: 0 },
        //price_base_type: String,
        //title: String,
        priceSpecific: { type: Boolean, default: false },
        pu_ht: {
            type: Number,
            default: 0
        },
        description: String,
        private: String, // Private note
        product_type: String,
        product: { type: Schema.Types.ObjectId, ref: "product" },
        total_taxes: [{
            _id: false,
            taxeId: { type: Schema.Types.ObjectId, ref: 'taxes' },
            value: { type: Number }
        }],
        discount: { type: Number, default: 0 },
        total_ht: { type: Number, default: 0, set: setPrice },
        //weight: { type: Number, default: 0 },
        optional: { type: Schema.Types.Mixed }
    }],*/
    history: [{
        date: {
            type: Date,
            default: Date.now
        },
        author: {
            type: ObjectId,
            ref: 'Users'
        },
        mode: String, //email, order, alert, new, ...
        Status: String,
        msg: String
    }],

    status: {},

    whoCanRW: {
        type: String,
        enum: ['owner', 'group', 'everyOne'],
        default: 'everyOne'
    },

    groups: {
        owner: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        users: [{
            type: ObjectId,
            ref: 'Users',
            default: null
        }],
        group: [{
            type: ObjectId,
            ref: 'Department',
            default: null
        }]
    },

    warehouse: {
        type: ObjectId,
        ref: 'warehouse'
    },
    project: {
        type: ObjectId,
        ref: 'Project',
        default: null
    },

    shippingMethod: {
        type: ObjectId,
        ref: 'shippingMethod'
    },

    //attachments: { type: Array, default: [] },
    files: {
        type: Array,
        default: []
    },



    channel: {
        type: ObjectId,
        ref: 'integrations'
    },
    integrationId: String,
    //sequence: Number,
    //name: String

}, options);

baseSchema.plugin(timestamps);

if (CONFIG('storing-files')) {
    var gridfs = INCLUDE(CONFIG('storing-files'));
    baseSchema.plugin(gridfs.pluginGridFs, {
        root: 'Orders'
    });
}

var orderCustomerSchema = new Schema({
    offer: {
        type: ObjectId,
        ref: 'order'
    },

    status: {
        allocateStatus: {
            type: String,
            default: 'NOR',
            enum: ['NOR', 'NOT', 'NOA', 'ALL']
        },
        fulfillStatus: {
            type: String,
            default: 'NOR',
            enum: ['NOR', 'NOT', 'NOA', 'ALL']
        },
        shippingStatus: {
            type: String,
            default: 'NOR',
            enum: ['NOR', 'NOT', 'NOA', 'ALL']
        }
    }
});

orderCustomerSchema.methods.setAllocated = function(newRows, callback) {
    if (!newRows || !newRows.length)
        return callback();

    const Availability = MODEL('productsAvailability').Schema;

    async.eachSeries(newRows, function(elem, eachCb) {

        var lastSum = elem.qty;
        var isFilled;

        //console.log(elem);

        Availability.find({
            warehouse: elem.warehouse,
            product: elem.product
        }, function(err, avalabilities) {
            if (err)
                return eachCb(err);

            if (avalabilities.length) {
                async.each(avalabilities, function(availability, cb) {
                    var allocated = 0;
                    var resultOnHand;
                    var existedRow = {
                        qty: 0
                    };

                    var allOnHand;

                    availability.orderRows.forEach(function(orderRow) {
                        if (orderRow.orderRowId.toString() === elem._id.toString())
                            existedRow = orderRow;
                        else
                            allocated += orderRow.qty;
                    });

                    if (isFilled && elem.qty)
                        return cb();


                    allOnHand = availability.onHand + existedRow.qty;

                    if (!allOnHand)
                        return cb();


                    resultOnHand = allOnHand - lastSum;

                    if (resultOnHand < 0) {
                        lastSum = Math.abs(resultOnHand);
                        resultOnHand = 0;
                    } else
                        isFilled = true;


                    if (existedRow.orderRowId) {

                        if (!elem.qty) {
                            Availability.update({
                                _id: availability._id
                            }, {
                                $inc: {
                                    onHand: existedRow.qty
                                },
                                $pull: {
                                    orderRows: {
                                        orderRowId: existedRow.orderRowId
                                    }
                                }
                            }, function(err) {
                                if (err)
                                    return cb(err);

                                cb();
                            });
                        } else {
                            Availability.update({
                                _id: availability._id,
                                'orderRows.orderRowId': existedRow.orderRowId
                            }, {
                                'orderRows.$.qty': resultOnHand ? lastSum : allOnHand,
                                onHand: resultOnHand
                            }, function(err) {
                                if (err)
                                    return cb(err);

                                cb();
                            });
                        }

                    } else if (elem.qty) {
                        Availability.findByIdAndUpdate(availability._id, {
                            $addToSet: {
                                orderRows: {
                                    orderRowId: elem._id,
                                    qty: resultOnHand ? lastSum : allOnHand
                                }
                            },
                            onHand: resultOnHand
                        }, function(err) {
                            if (err)
                                return cb(err);

                            cb();
                        });
                    } else {
                        return cb();
                    }

                    setTimeout2('productInventory:' + availability.product.toString(), function() {
                        F.emit('inventory:update', {
                            userId: null,
                            product: {
                                _id: availability.product.toString()
                            }
                        });
                    }, 5000);

                }, function(err) {
                    if (err)
                        return eachCb(err);

                    eachCb();
                });
            } else
                eachCb();

        });

    }, callback);
};


var orderSupplierSchema = new Schema({
    offer: {
        type: ObjectId,
        ref: 'order'
    },

    status: {
        allocateStatus: {
            type: String,
            default: 'NOR',
            enum: ['NOR', 'NOT', 'NOA', 'ALL']
        },
        fulfillStatus: {
            type: String,
            default: 'NOR',
            enum: ['NOR', 'NOT', 'NOA', 'ALL']
        },
        shippingStatus: {
            type: String,
            default: 'NOR',
            enum: ['NOR', 'NOT', 'NOA', 'ALL']
        }
    }
});

var quotationCustomerSchema = new Schema({
    orders: [{
        type: ObjectId,
        ref: 'order'
    }]
});
var quotationSupplierSchema = new Schema({
    orders: [{
        type: ObjectId,
        ref: 'order'
    }]
});

// Gets listing
baseSchema.statics.query = function(options, callback) {
    var self = this;

    // options.search {String}
    // options.category {String}
    // options.page {String or Number}
    // options.max {String or Number}
    // options.id {String}

    options.page = U.parseInt(options.page) - 1;
    options.max = U.parseInt(options.max, 20);
    if (options.id && typeof(options.id) === 'string')
        options.id = options.id.split(',');
    if (options.page < 0)
        options.page = 0;
    var take = U.parseInt(options.max);
    var skip = U.parseInt(options.page * options.max);

    var query = options.query;
    if (!query.isremoved)
        query.isremoved = {
            $ne: true
        };

    //if (options.search)
    //    builder.in('search', options.search.keywords(true, true));
    if (options.id) {
        if (typeof options.id === 'object')
            options.id = {
                '$in': options.id
            };
        query._id = options.id;
    }

    var sort = "ref";

    if (options.sort)
        sort = options.sort;

    //console.log(query);

    this.find(query)
        .select(options.fields)
        .limit(take)
        .skip(skip)
        //.populate('category', "_id path url linker name")
        .sort(sort)
        //.lean()
        .exec(function(err, doc) {
            //console.log(doc);
            var data = {};
            data.count = doc.length;
            data.items = doc;
            data.limit = options.max;
            data.pages = Math.ceil(data.count / options.max);

            if (!data.pages)
                data.pages = 1;
            data.page = options.page + 1;
            callback(null, data);
        });
};

// Read Order
/*baseSchema.statics.getById = function(id, callback) {
    var self = this;
    var OrderRowModel = MODEL('orderRows').Schema;

    //TODO Check ACL here
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    var query = {};

    if (checkForHexRegExp.test(id))
        query = {
            _id: id
        };
    else
        query = {
            ref: id
        };

    //console.log(query);

    self.findOne(query, "-latex")
        .populate("contacts", "name phone email")
        .populate({
            path: "supplier",
            select: "name salesPurchases",
            populate: { path: "salesPurchases.priceList" }
        })
        .populate({
            path: "total_taxes.taxeId"
        })
        .populate("createdBy", "username")
        .populate("editedBy", "username")
        .populate("offer", "ref total_ht forSales")
        .populate("order", "ref total_ht forSales")
        .populate("orders", "ref total_ht forSales")
        .exec(function(err, order) {
            if (err)
                return callback(err);

            if (!order.order)
                order.order = { _id: order._id };

            OrderRowModel.find({ order: order.order._id, isDeleted: { $ne: true } })
                .populate({
                    path: "product",
                    select: "taxes info weight units",
                    //populate: { path: "taxes.taxeId" }
                })
                .populate({
                    path: "total_taxes.taxeId"
                })
                .sort({ sequence: 1 })
                .exec(function(err, rows) {
                    if (err)
                        return callback(err);

                    order = order.toObject();
                    order.lines = rows || [];

                    return callback(err, order);
                });
        });
};*/
baseSchema.statics.getById = function(id, callback) {
    var self = this;
    var OrderRowModel = MODEL('orderRows').Schema;
    var ObjectId = MODULE('utils').ObjectId;

    //TODO Check ACL here
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    var query = {};

    if (checkForHexRegExp.test(id))
        query = {
            _id: id
        };
    else
        query = {
            ref: id
        };

    //console.log(query);

    async.waterfall([
            function(wCb) {
                self.findOne(query, "-latex")
                    .populate("contacts", "name phones emails")
                    .populate({
                        path: "supplier",
                        select: "name salesPurchases",
                        populate: {
                            path: "salesPurchases.priceList"
                        }
                    })
                    .populate({
                        path: "total_taxes.taxeId"
                    })
                    .populate("createdBy", "username")
                    .populate("editedBy", "username")
                    .populate("offer", "ref total_ht forSales")
                    .populate("order", "ref total_ht forSales")
                    .populate("orders", "ref total_ht forSales")
                    .populate({
                        path: "orderRows.product",
                        select: "taxes info weight units",
                        populate: {
                            path: "info.productType"
                        } //For delivery stock
                    })
                    .populate("orderRows.locationsReceived.location", "_id name")
                    .populate('warehouse', 'name')
                    .populate('invoiceControl')
                    .populate('project', '_id name')
                    .populate('shippingMethod', '_id name')
                    .populate('logisticMethod', '_id name weight price')
                    .populate('workflow', '_id name status')
                    .exec(wCb);
            },
            function(order, wCb) {
                if (!order)
                    return wCb(null, null);

                if (!order.order)
                    order.order = {
                        _id: order._id
                    };

                //return console.log(order.orderRows);

                OrderRowModel.find({
                        order: order.order._id,
                        isDeleted: {
                            $ne: true
                        }
                    })
                    .populate({
                        path: "product",
                        select: "taxes info weight units sellFamily",
                        populate: {
                            path: "info.productType"
                        }
                    })
                    .populate({
                        path: "total_taxes.taxeId"
                    })
                    .populate('warehouse', 'name')
                    .sort({
                        sequence: 1
                    })
                    .lean()
                    .exec(function(err, rows) {
                        if (err)
                            return wCb(err);

                        //return console.log(rows);

                        OrderRowModel.getAvailableForRows(rows, order.forSales, function(err, rows, deliveries) {
                            //return console.log(rows);

                            rows = _.sortBy(rows, 'sequence');

                            order = order.toObject();

                            //Fix orderRowId to String
                            order.orderRows = _.map(order.orderRows, function(elem) {
                                //return console.log(elem);
                                elem.orderRowId = elem.orderRowId.toString();
                                return elem;
                            });
                            rows = _.map(rows, function(elem) {
                                //return console.log(elem);
                                elem._id = elem._id.toString();
                                return elem;
                            });

                            order.lines = rows || [];

                            //console.log(deliveries);

                            return wCb(err, order);
                        });
                    });
            },
            function(order, wCb) {
                if (!order)
                    return wCb(null, null, null);

                OrderRowModel.aggregate([{
                            $match: {
                                order: ObjectId(order.order._id),
                                isDeleted: {
                                    $ne: true
                                },
                                type: {
                                    $in: ['product', 'kit']
                                }
                            }
                        },
                        {
                            $lookup: {
                                from: 'Product',
                                localField: 'product',
                                foreignField: '_id',
                                as: 'product'
                            }
                        },
                        {
                            $unwind: {
                                path: '$product'
                            }
                        },
                        {
                            $lookup: {
                                from: 'productTypes',
                                localField: 'product.info.productType',
                                foreignField: '_id',
                                as: 'productType'
                            }
                        },
                        {
                            $unwind: {
                                path: '$productType'
                            }
                        },
                        {
                            $lookup: {
                                from: 'Orders',
                                localField: 'order',
                                foreignField: 'order',
                                as: 'deliveries'
                            }
                        },
                        {
                            $project: {
                                _id: 1,
                                isService: "$productType.isService",
                                'product._id': 1,
                                'product.info.SKU': 1,
                                'product.info.langs': 1,
                                'product.info.productType': 1,
                                'product.weight': 1,
                                'product.directCost': 1,
                                orderQty: "$qty",
                                order: 1,
                                sequence: 1,
                                "deliveries": {
                                    "$filter": {
                                        "input": "$deliveries",
                                        "as": "delivery",
                                        "cond": {
                                            $and: [{
                                                $ne: ["$$delivery.isremoved", true]
                                            }, {
                                                $or: [{
                                                    $eq: ['$$delivery._type', 'GoodsOutNote']
                                                }, {
                                                    $eq: ['$$delivery._type', 'GoodsInNote']
                                                }]
                                            }]
                                        }
                                    }
                                },
                                refProductSupplier: 1,
                                description: 1
                            }
                        },
                        {
                            $match: {
                                isService: {
                                    $ne: true
                                }
                            }
                        },
                        {
                            $project: {
                                _id: 1,
                                inventory: 1,
                                product: 1,
                                orderQty: 1,
                                order: 1,
                                sequence: 1,
                                "deliveries": {
                                    "$filter": {
                                        "input": "$deliveries",
                                        "as": "delivery",
                                        "cond": {
                                            $ne: ["$$delivery._id", ObjectId(order._id)]
                                        }
                                    }
                                },
                                refProductSupplier: 1,
                                description: 1
                            }
                        },
                        {
                            $unwind: {
                                path: '$deliveries',
                                preserveNullAndEmptyArrays: true
                            }
                        },
                        {
                            $project: {
                                _id: 1,
                                orderQty: 1,
                                order: 1,
                                product: 1,
                                sequence: 1,
                                'deliveries.ref': 1,
                                'deliveries._id': 1,
                                'deliveries.status': 1,
                                'deliveries.datedl': 1,
                                'deliveries.orderRows': {
                                    $filter: {
                                        input: "$deliveries.orderRows",
                                        as: "row",
                                        cond: {
                                            $eq: ["$$row.orderRowId", "$_id"]
                                        }
                                    }
                                },
                                refProductSupplier: 1,
                                description: 1
                            }
                        },
                        {
                            $unwind: {
                                path: '$deliveries.orderRows',
                                preserveNullAndEmptyArrays: true
                            }
                        },
                        {
                            $group: {
                                _id: "$_id",
                                orderQty: {
                                    $first: "$orderQty"
                                },
                                sequence: {
                                    $first: "$sequence"
                                },
                                product: {
                                    $first: "$product"
                                },
                                deliveryQty: {
                                    $sum: "$deliveries.orderRows.qty"
                                },
                                deliveries: {
                                    $addToSet: {
                                        _id: "$deliveries._id",
                                        ref: "$deliveries.ref",
                                        qty: "$deliveries.orderRows.qty",
                                        datedl: "$deliveries.datedl",
                                        status: "$deliveries.status"
                                    }
                                },
                                refProductSupplier: {
                                    $first: "$refProductSupplier"
                                },
                                description: {
                                    $first: "$description"
                                }
                            }
                        },
                        {
                            $project: {
                                _id: 0,
                                orderRowId: "$_id",
                                orderQty: 1,
                                qty: {
                                    $subtract: ["$orderQty", "$deliveryQty"]
                                },
                                sequence: 1,
                                product: 1,
                                cost: "$product.directCost",
                                deliveryQty: 1,
                                deliveries: 1,
                                refProductSupplier: 1,
                                description: 1
                            }
                        },
                        {
                            $sort: {
                                sequence: 1
                            }
                        }
                    ],
                    function(err, result) {
                        wCb(err, order, result);
                    });
            }
        ],
        function(err, order, orderRows) {
            if (err)
                return callback(err);

            if (!order)
                return callback(null, null);

            //return console.log(orderRows, order.orderRows);

            //if (!order.orderRows.length)

            let firstCreateDelivery = true;

            if (order.orderRows.length > 0)
                firstCreateDelivery = false;

            order.orderRows = _.map(orderRows, function(item) {
                if (!firstCreateDelivery) {
                    delete item.qty;
                }

                //console.log(item.orderRowId, order.orderRows);
                //console.log('test', _.find(order.orderRows, _.matchesProperty('orderRowId', item.orderRowId.toString())));

                item = _.extend(item, _.find(order.orderRows, _.matchesProperty('orderRowId', item.orderRowId.toString())));
                if (item.qty === undefined)
                    item.isDeleted = true;

                return item;
            });
            //return console.log(order.orderRows);

            //Add onHand in delivery lines
            order.orderRows = _.map(order.orderRows, function(item) {
                var data = _.find(order.lines, _.matchesProperty('_id', item.orderRowId));

                if (!data || !data.onHand)
                    data = {
                        onHand: 0
                    };

                //console.log(data);

                if (order.Status == 'DRAFT' && item.qty > (data.onHand + data.allocated))
                    item.qty = data.onHand + data.allocated;

                return _.extend(item, {
                    onHand: data.onHand,
                    fulfilled: data.fulfilled
                });
            });

            //console.log(order.orderRows);
            return callback(err, order);
        });
};

//orderSupplierSchema.statics.getById = getById;

/**
 * Methods
 */
baseSchema.virtual('_status')
    .get(function() {
        var res_status = {};

        var status = this.Status;
        var statusList = exports.Status;

        if (status && statusList.values[status] && statusList.values[status].label) {
            res_status.id = status;
            res_status.name = i18n.t("orders:" + statusList.values[status].label);
            //this.status.name = statusList.values[status].label;
            res_status.css = statusList.values[status].cssClass;
        } else { // By default
            res_status.id = status;
            res_status.name = status;
            res_status.css = "";
        }

        return res_status;
    });

//Check if orderRow is attached to this main order
baseSchema.virtual('_isOwn')
    .get(function() {
        if (!this.order)
            return false;

        return (this._id === this.order || this._id === this.order._id);
    });



const Order = mongoose.model('order', baseSchema);

/**
 * Delivery
 */

var goodsOutNoteSchema = new Schema({

    orderRows: [{
        _id: false,
        orderRowId: {
            type: ObjectId,
            ref: 'orderRows',
            default: null
        },
        product: {
            type: ObjectId,
            ref: 'product',
            default: null
        },
        locationsDeliver: [{
            type: ObjectId,
            ref: 'location'
        }],
        cost: {
            type: Number,
            default: 0
        },
        qty: Number,

        isDeleted: {
            type: Boolean,
            default: false
        }
    }],

    tracking: String, //Tracking number

    status: {
        isPrinted: {
            type: Date,
            default: null
        }, //Imprime
        isPicked: {
            type: Date,
            default: null
        }, //Prepare
        isPacked: {
            type: Date,
            default: null
        }, //Emballe
        isShipped: {
            type: Date,
            default: null
        }, //Expedier
        isInventory: {
            type: Date,
            default: null
        }, //Inventory done

        pickedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        packedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        shippedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        printedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        }
    },

    logisticMethod: {
        type: ObjectId,
        ref: 'logisticMethod'
    },
    shippingCost: {
        shipping: {
            type: Number,
            default: 0
        },
        logistic: {
            type: Number,
            default: 0
        }
    },

    boxes: {
        type: Number,
        default: 1
    },

    archived: {
        type: Boolean,
        default: false
    }
});

goodsOutNoteSchema.statics.cancelInventories = function(options, callback) {
    var GoodsOutNoteModel = this;
    const Availability = MODEL('productsAvailability').Schema;
    var ids = options.ids || [];
    var isMO = options.isManufacturing || false;
    var orderType = 'order';

    if (isMO)
        orderType = 'manufacturingOrder';


    async.each(ids, function(id, cb) {
        GoodsOutNoteModel.findById(id).populate(orderType).exec(function(err, goodsNote) {
            var options;

            if (err)
                return cb(err);

            if (goodsNote && goodsNote[orderType]) {
                async.each(goodsNote.orderRows, function(goodsOrderRow, callback) {

                    var query = goodsNote[orderType].project ? {
                        product: goodsOrderRow.product,
                        warehouse: goodsNote.warehouse
                    } : {
                        'goodsOutNotes.goodsNoteId': goodsNote._id,
                        product: goodsOrderRow.product,
                        warehouse: goodsNote.warehouse
                    };

                    Availability.updateByQuery({
                        query: query,

                        body: {
                            $inc: {
                                onHand: goodsOrderRow.qty
                            },

                            $pull: {
                                goodsOutNotes: {
                                    goodsNoteId: goodsNote._id
                                }
                            }
                        }
                    }, function(err) {
                        if (err)
                            return callback(err);


                        options = {
                            query: {
                                'sourceDocument.model': 'goodsOutNote',
                                'sourceDocument._id': id
                            }
                        };

                        //JournalEntryService.remove(options);

                        callback();
                    });
                }, function(err) {
                    if (err)
                        return cb(err);

                    F.emit('order:recalculateStatus', {
                        order: {
                            _id: goodsNote[orderType]._id.toString()
                        }
                    });
                    cb();
                });

            } else {
                cb();
            }
        });
    }, function(err) {
        if (err) {
            return callback(err);
        }

        GoodsOutNoteModel.update({
            _id: {
                $in: ids
            }
        }, {
            $set: {
                Status: "DRAFT",
                'status.isInventory': null
            }
        }, {
            multi: true
        }, function(err, result) {
            if (err)
                return callback(err);

            callback();
        });
    });
};

var goodsInNoteSchema = new Schema({

    status: {
        isReceived: {
            type: Date,
            default: null
        },
        isInventory: {
            type: Date,
            default: null
        }, //Inventory done

        receivedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        }
    },

    description: {
        type: String
    },

    boxes: {
        type: Number,
        default: 1
    },

    orderRows: [{
        _id: false,
        orderRowId: {
            type: ObjectId,
            ref: 'orderRows',
            default: null
        },
        product: {
            type: ObjectId,
            ref: 'product',
            default: null
        },
        cost: {
            type: Number,
            default: 0
        },
        locationsReceived: [{
            _id: false,
            location: {
                type: ObjectId,
                ref: 'location',
                default: null
            },
            qty: Number
        }],

        isDeleted: {
            type: Boolean,
            default: false
        },

        qty: Number
    }],

    logisticMethod: {
        type: ObjectId,
        ref: 'logisticMethod'
    },
    shippingCost: {
        shipping: {
            type: Number,
            default: 0
        },
        logistic: {
            type: Number,
            default: 0
        }
    }

});

var stockCorrectionSchema = new Schema({
    status: {
        isReceived: {
            type: Date,
            default: null
        },
        isInventory: {
            type: Date,
            default: null
        }, //Inventory done

        receivedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        }
    },

    description: {
        type: String
    },

    boxes: {
        type: Number,
        default: 1
    },

    location: {
        type: ObjectId,
        ref: 'location',
        default: null
    },

    orderRows: [{
        _id: false,
        orderRowId: {
            type: ObjectId,
            ref: 'orderRows',
            default: null
        },
        product: {
            type: ObjectId,
            ref: 'product',
            default: null
        },
        cost: {
            type: Number,
            default: 0
        },
        locationsReceived: [{
            _id: false,
            location: {
                type: ObjectId,
                ref: 'location',
                default: null
            },
            qty: Number
        }],

        qty: Number
    }]
});

var stockReturnSchema = new Schema({
    status: {
        isReceived: {
            type: Date,
            default: null
        },
        isInventory: {
            type: Date,
            default: null
        }, //Inventory done

        receivedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        }
    },

    description: {
        type: String
    },

    boxes: {
        type: Number,
        default: 1
    },

    journalEntrySources: [{
        type: String,
        default: ''
    }],

    orderRows: [{
        _id: false,
        orderRowId: {
            type: ObjectId,
            ref: 'orderRows',
            default: null
        },
        product: {
            type: ObjectId,
            ref: 'product',
            default: null
        },
        cost: {
            type: Number,
            default: 0
        },
        locationsReceived: [{
            _id: false,
            location: {
                type: ObjectId,
                ref: 'location',
                default: null
            },
            qty: Number
        }],

        isDeleted: {
            type: Boolean,
            default: false
        },

        qty: Number
        /*
                _id: false,
                goodsOutNote: { type: ObjectId, ref: 'GoodsOutNote', default: null },
                goodsInNote: { type: ObjectId, ref: 'GoodsInNote', default: null },
                product: { type: ObjectId, ref: 'product', default: null },
                cost: { type: Number, default: 0 },
                qty: Number,
                warehouse: { type: ObjectId, ref: 'warehouse', default: null }*/
    }]
});

// OF ordre de fabrication
var ordersFabSchema = new Schema({
    status: {
        isPrinted: {
            type: Date,
            default: null
        }, //Imprime
        isPicked: {
            type: Date,
            default: null
        }, //Prepare
        isPacked: {
            type: Date,
            default: null
        }, //Emballe
        isShipped: {
            type: Date,
            default: null
        }, //Expedier
        isInventory: {
            type: Date,
            default: null
        }, //Inventory done

        pickedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        packedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        shippedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        printedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        }
    },

    description: {
        type: String
    },

    orderRows: [{
        _id: false,
        product: {
            type: ObjectId,
            ref: 'Product',
            default: null
        },
        cost: {
            type: Number,
            default: 0
        },
        qty: Number,
        warehouse: {
            type: ObjectId,
            ref: 'warehouse',
            default: null
        }
    }]
});

var stockTransactionsSchema = new Schema({
    warehouseTo: {
        type: ObjectId,
        ref: 'warehouse',
        default: null
    },
    status: {
        isPrinted: {
            type: Date,
            default: null
        }, //Imprime
        isPicked: {
            type: Date,
            default: null
        }, //Prepare
        isPacked: {
            type: Date,
            default: null
        }, //Emballe
        isShipped: {
            type: Date,
            default: null
        }, //Expedier
        isInventory: {
            type: Date,
            default: null
        }, //Inventory done

        pickedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        packedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        shippedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        },
        printedById: {
            type: ObjectId,
            ref: 'Users',
            default: null
        }
    },

    boxes: {
        type: Number,
        default: 1
    },

    orderRows: [{
        _id: false,
        orderRowId: {
            type: ObjectId,
            ref: 'orderRows',
            default: null
        },
        product: {
            type: ObjectId,
            ref: 'Product',
            default: null
        },
        locationsDeliver: [{
            type: ObjectId,
            ref: 'location'
        }],
        batchesDeliver: [{
            _id: false,
            goodsNote: {
                type: ObjectId,
                ref: 'goodsInNotes',
                default: null
            },
            qty: Number,
            cost: Number
        }],

        locationsReceived: [{
            _id: false,
            location: {
                type: ObjectId,
                ref: 'location',
                default: null
            },
            qty: Number
        }],

        cost: {
            type: Number,
            default: 0
        },
        qty: Number
    }]

});

function saveOrder(next) {
    var self = this;
    var SeqModel = MODEL('Sequence').Schema;
    var EntityModel = MODEL('entity').Schema;
    var WarehouseModel = MODEL('warehouse').Schema;

    if (this.isNew)
        this.history = [];

    async.waterfall([
        function(wCb) {
            if (self.warehouse && self.forSales == true)
                return wCb();

            if (self.warehouse && self.forSales == false) // Refresh shipping address
                return WarehouseModel.findById(self.warehouse, "_id address", function(err, warehouse) {
                    if (warehouse && self.Status == "DRAFT")
                        self.shippingAddress = warehouse.address;

                    return wCb();
                });

            return WarehouseModel.findOne({
                main: true
            }, "_id", function(err, warehouse) {
                if (warehouse) {
                    self.warehouse = warehouse._id;
                    self.shippingAddress = warehouse.address;
                }


                return wCb();
            });
        },
        function(wCb) {
            if (!self.isNew || self.ref)
                return wCb();

            return SeqModel.inc((self.forSales == true ? "CO" : "CF"), function(seq, number) {
                //console.log(seq);
                self.ID = number;
                EntityModel.findOne({
                    _id: self.entity
                }, "cptRef", function(err, entity) {
                    if (err)
                        console.log(err);

                    if (self.forSales == true)
                        if (entity && entity.cptRef)
                            self.ref = "CO" + entity.cptRef + seq;
                        else
                            self.ref = "CO" + seq;
                    else
                        self.ref = "CF" + seq;

                    wCb();
                });
            });
        },
        function(wCb) {
            if (self.datedl)
                self.ref = F.functions.refreshSeq(self.ref, self.datedl);

            wCb();
        }
    ], function(err) {
        next();
    });
}

function saveQuotation(next) {
    var self = this;
    var SeqModel = MODEL('Sequence').Schema;
    var EntityModel = MODEL('entity').Schema;

    if (this.isNew)
        this.history = [];

    if (self.isNew && !self.ref)
        return SeqModel.inc((self.forSales == true ? "PC" : "DA"), function(seq, number) {
            //console.log(seq);
            self.ID = number;
            EntityModel.findOne({
                _id: self.entity
            }, "cptRef", function(err, entity) {
                if (err)
                    console.log(err);

                if (self.forSales == true)
                    if (entity && entity.cptRef)
                        self.ref = "PC" + entity.cptRef + seq;
                    else
                        self.ref = "PC" + seq;
                else
                    self.ref = "DA" + seq;

                next();
            });
        });

    self.ref = F.functions.refreshSeq(self.ref, self.datec);
    next();
}

function setNameDelivery(next) {
    var self = this;
    var SeqModel = MODEL('Sequence').Schema;
    var EntityModel = MODEL('entity').Schema;
    var OrderModel = MODEL('order').Schema.Order;

    if (self.isNew && self.order === self._id)
        return SeqModel.inc((self.forSales == true ? "CO" : "CF"), function(seq, number) {
            //console.log(seq);
            self.ID = number;
            EntityModel.findOne({
                _id: self.entity
            }, "cptRef", function(err, entity) {
                if (err)
                    console.log(err);

                if (self.forSales == true)
                    if (entity && entity.cptRef)
                        self.ref = "BL" + entity.cptRef + seq;
                    else
                        self.ref = "BL" + seq;
                else
                    self.ref = "RE" + seq;

                next();
            });
        });

    if (self.isNew && !self.ref)
        return OrderModel.findById(self.order, "ref ID", function(err, order) {
            SeqModel.incCpt(order._id, function(number) {
                //console.log(seq);

                self.ref = (self.forSales == true ? "BL" : "RE") + order.ref.substring(2) + '/' + number;

                next();
            });
        });

    if (self.datedl)
        self.ref = F.functions.refreshSeq(self.ref, self.datedl);
    next();
}

function setNameTransfer(next) {
    var transaction = this;
    var db = transaction.db.db;
    var prefix = 'TX';

    db.collection('settings').findOneAndUpdate({
        dbName: db.databaseName,
        name: prefix
    }, {
        $inc: {
            seq: 1
        }
    }, {
        returnOriginal: false,
        upsert: true
    }, function(err, rate) {
        if (err) {
            return next(err);
        }

        transaction.name = prefix + '-' + rate.value.seq;

        next();
    });
}

function setNameReturns(next) {
    var self = this;
    var SeqModel = MODEL('Sequence').Schema;
    var EntityModel = MODEL('entity').Schema;
    var OrderModel = MODEL('order').Schema.Order;
    var WarehouseModel = MODEL('warehouse').Schema;

    async.waterfall([
        function(wCb) {
            if (self.warehouse) // Refresh shipping address
                return WarehouseModel.findById(self.warehouse, "_id address", function(err, warehouse) {
                    if (warehouse && self.Status == "DRAFT")
                        self.shippingAddress = warehouse.address;

                    return wCb();
                });

            WarehouseModel.findOne({
                main: true
            }, "_id", function(err, warehouse) {
                if (warehouse) {
                    self.warehouse = warehouse._id;
                    self.shippingAddress = warehouse.address;
                }

                return wCb();
            });
        },
        function(wCb) {

            if (self.isNew && !self.ref)
                return OrderModel.findById(self.order, "ref ID", function(err, order) {
                    SeqModel.incCpt(order._id, function(number) {
                        //console.log(seq);

                        self.ref = "RT" + order.ref.substring(2) + '/' + number;

                        wCb();
                    });
                });

            wCb();
        },
        function(wCb) {
            if (self.datedl)
                self.ref = F.functions.refreshSeq(self.ref, self.datedl);

            wCb();
        }
    ], function(err) {
        next();
    });
}

function setNameOrdersFab(next) {
    var self = this;
    var SeqModel = MODEL('Sequence').Schema;
    var EntityModel = MODEL('entity').Schema;

    if (this.isNew)
        this.history = [];

    if (self.isNew && !self.ref)
        return SeqModel.inc("OF", function(seq, number) {
            //console.log(seq);
            self.ID = number;

            self.ref = "OF" + seq;
            next();

        });

    self.ref = F.functions.refreshSeq(self.ref, self.datec);
    next();
}

orderCustomerSchema.pre('save', saveOrder);
orderSupplierSchema.pre('save', saveOrder);
quotationCustomerSchema.pre('save', saveQuotation);
quotationSupplierSchema.pre('save', saveQuotation);

goodsOutNoteSchema.pre('save', setNameDelivery);
stockTransactionsSchema.pre('save', setNameTransfer);
goodsInNoteSchema.pre('save', setNameDelivery);
stockReturnSchema.pre('save', setNameReturns);

ordersFabSchema.pre('save', setNameOrdersFab);


//goodsOutNoteSchema.statics.getById = getDeliveryById;
//goodsInNoteSchema.statics.getById = getDeliveryById;

const orderCustomer = Order.discriminator('orderCustomer', orderCustomerSchema);
const orderSupplier = Order.discriminator('orderSupplier', orderSupplierSchema);
const quotationCustomer = Order.discriminator('quotationCustomer', quotationCustomerSchema);
const quotationSupplier = Order.discriminator('quotationSupplier', quotationSupplierSchema);

const goodsOutNote = Order.discriminator('GoodsOutNote', goodsOutNoteSchema);
const stockTransactions = Order.discriminator('stockTransactions', stockTransactionsSchema);
const stockReturns = Order.discriminator('stockReturns', stockReturnSchema);
const stockCorrection = Order.discriminator('stockCorrections', stockCorrectionSchema);
const goodsInNote = Order.discriminator('GoodsInNote', goodsInNoteSchema);

const ordersFab = Order.discriminator('OrdersFab', ordersFabSchema);

exports.Schema = {
    Order: Order, //Only for READING
    OrderCustomer: orderCustomer,
    OrderSupplier: orderSupplier,
    QuotationCustomer: quotationCustomer,
    QuotationSupplier: quotationSupplier,

    GoodsOutNote: goodsOutNote,
    GoodsInNote: goodsInNote,
    StockCorrections: stockCorrection,
    stockTransactions: stockTransactions,
    stockReturns: stockReturns,

    OrdersFab: ordersFab
};

exports.Status = {
    "_id": "fk_order_status",
    "lang": "orders",
    "values": {
        "DRAFT": {
            "enable": true,
            "label": "StatusOrderDraft",
            "cssClass": "ribbon-color-default label-default",
            "system": true
        },
        "VALIDATED": {
            "enable": true,
            "label": "StatusOrderValidated",
            "cssClass": "ribbon-color-warning label-warning"
        },
        "CANCELED": {
            "enable": true,
            "label": "StatusOrderCanceled",
            "cssClass": "ribbon-color-danger label-danger",
            "system": true
        },
        "SEND": {
            "enable": true,
            "label": "StatusOrderSend",
            "cssClass": "ribbon-color-success label-success"
        },
        "PROCESSING": {
            "enable": true,
            "label": "StatusOrderProcessing",
            "cssClass": "ribbon-color-info label-info"
        },
        "SHIPPING": {
            "label": "StatusOrderSending",
            "enable": true,
            "cssClass": "ribbon-color-success label-success"
        },
        "ADMISSION": {
            "label": "StatusOrderOnProcess",
            "enable": true,
            "cssClass": "ribbon-color-success label-success"
        },
        "CLOSED": {
            "enable": true,
            "label": "StatusOrderClosed",
            "cssClass": "ribbon-color-success label-success",
            "system": true
        },
        "ERROR": {
            "label": "StatusOrderError",
            "cssClass": "ribbon-color-danger label-danger",
            "system": true
        },
        "BILLING": {
            "label": "StatusOrderToBill",
            "cssClass": "ribbon-color-default label-default"
        },
        "BILLED": {
            "enable": true,
            "label": "StatusOrderToBill",
            "cssClass": "ribbon-color-primary label-primary",
            "system": true
        },
        "INSTOCK": {
            "enable": true,
            "label": "StatusDeliveryInStock",
            "cssClass": "ribbon-color-success label-success",
            "system": true
        },
        "NEW": {
            "enable": true,
            "label": "PropalStatusNew",
            "cssClass": "ribbon-color-warning label-warning"
        },
        "SIGNED": {
            "enable": true,
            "label": "PropalStatusClosed",
            "cssClass": "ribbon-color-info label-info",
            "system": true
        },
        "NOTSIGNED": {
            "enable": true,
            "label": "PropalStatusNotSigned",
            "cssClass": "ribbon-color-danger label-danger",
            "system": true
        }
    }
};

exports.name = "order";


// Refresh pack prices from directCost
F.on('order:recalculateStatus', function(data) {
    var userId = data.userId;
    const OrderRows = MODEL('orderRows').Schema;
    var ObjectId = MODULE('utils').ObjectId;

    //console.log(data);
    console.log("Update emit order", data);

    if (!data.order || !data.order._id)
        return;

    function getAvailableForRows(docs, cb) {
        var Availability;
        var GoodsOutNote;

        Availability = MODEL('productsAvailability').Schema;
        GoodsOutNote = exports.Schema.Order;

        var stockStatus = {};

        if (docs && docs.length && docs[0].order.Status != "DRAFT" && docs[0].order.Status != "NEW") {
            async.eachSeries(docs, function(elem, eahcCb) {
                    var product;

                    elem = elem.toJSON();
                    product = elem.product ? elem.product._id : null;

                    if (!elem.qty || elem.isDeleted)
                        return eahcCb();

                    if (elem.product.info.productType.isService == true)
                        return eahcCb();

                    Availability.aggregate([{
                        $match: {
                            product: ObjectId(product),
                            warehouse: elem.warehouse
                        }
                    }, {
                        $project: {
                            product: 1,
                            warehouse: 1,
                            onHand: 1,
                            filterRows: {
                                $filter: {
                                    input: '$orderRows',
                                    as: 'elem',
                                    cond: {
                                        $eq: ['$$elem.orderRowId', elem._id]
                                    }
                                }
                            },
                            orderRows: 1
                        }
                    }, {
                        $project: {
                            product: 1,
                            warehouse: 1,
                            onHand: 1,
                            allocated: {
                                $sum: '$filterRows.qty'
                            }
                        }
                    }, {
                        $project: {
                            product: 1,
                            warehouse: 1,
                            onHand: 1,
                            allocated: 1
                        }
                    }, {
                        $group: {
                            _id: '$warehouse',
                            allocated: {
                                $sum: '$allocated'
                            }
                        }
                    }], function(err, availability) {
                        if (err)
                            return eahcCb(err);

                        //return console.log(availability);

                        GoodsOutNote.aggregate([{
                            $match: {
                                'orderRows.orderRowId': elem._id,
                                _type: {
                                    $ne: 'stockReturns'
                                },
                                "status.isInventory": {
                                    $ne: null
                                },
                                isremoved: {
                                    $ne: true
                                }
                            }
                        }, {
                            $project: {
                                ref: '$ref',
                                orderRow: {
                                    $filter: {
                                        input: '$orderRows',
                                        as: 'elem',
                                        cond: {
                                            $eq: ['$$elem.orderRowId', elem._id]
                                        }
                                    }
                                },

                                status: 1
                            }
                        }, {
                            $project: {
                                ref: '$ref',
                                orderRow: {
                                    $arrayElemAt: ['$orderRow', 0]
                                },
                                status: 1
                            }
                        }, {
                            $project: {
                                ref: '$ref',
                                orderRow: '$orderRow.orderRowId',
                                qty: '$orderRow.qty',
                                status: 1
                            }
                        }], function(err, docs) {
                            var fullfillOnRow = 0;
                            var shippedOnRow = 0;
                            var allocatedOnRow;
                            var shippedDocs;

                            //console.log(docs);

                            if (err)
                                return eahcCb(err);

                            availability = availability && availability.length ? availability[0].allocated : 0;



                            if (!docs || !docs.length) {

                                if (!stockStatus.fulfillStatus)
                                    stockStatus.fulfillStatus = 'NOT';

                                stockStatus.fulfillStatus = (stockStatus.fulfillStatus === 'NOA') || (stockStatus.fulfillStatus === 'ALL') ? 'NOA' : 'NOT';
                                stockStatus.shippingStatus = (stockStatus.shippingStatus === 'NOA') || (stockStatus.shippingStatus === 'ALL') ? 'NOA' : 'NOT';

                            } else {

                                //console.log(stockStatus);

                                shippedDocs = _.filter(docs, function(el) {
                                    if (el.status && (el.status.isShipped || el.status.isReceived))
                                        return el;
                                });

                                if (shippedDocs.length) {
                                    shippedDocs.forEach(function(el) {
                                        if (el.qty)
                                            shippedOnRow += el.qty;
                                    });

                                    if (shippedOnRow !== elem.qty)
                                        stockStatus.shippingStatus = 'NOA';
                                    else
                                        stockStatus.shippingStatus = stockStatus.shippingStatus && (stockStatus.shippingStatus === 'NOA') ? 'NOA' : 'ALL';

                                } else
                                    stockStatus.shippingStatus = ((stockStatus.shippingStatus === 'NOA') || (stockStatus.shippingStatus === 'ALL')) ? 'NOA' : 'NOT';


                                docs.forEach(function(el) {
                                    if (el.qty)
                                        fullfillOnRow += el.qty;
                                });

                                //console.log("test", fullfillOnRow, elem.qty);

                                if (fullfillOnRow !== elem.qty)
                                    stockStatus.fulfillStatus = (stockStatus.fulfillStatus === 'NOA') ? 'NOA' : 'NOT';
                                else if (!stockStatus.fulfillStatus || stockStatus.fulfillStatus == 'ALL')
                                    stockStatus.fulfillStatus = 'ALL';
                                else
                                    stockStatus.fulfillStatus = 'NOA';

                                //console.log(stockStatus);
                            }

                            allocatedOnRow = fullfillOnRow + availability;

                            //console.log(availability);

                            if (!elem.product.info.productType.inventory) {
                                //Not IN STOCK Managment
                                // Allocated ALL

                                if (!stockStatus.allocateStatus)
                                    stockStatus.allocateStatus = "ALL";
                                //else
                                //    stockStatus.allocateStatus = ((stockStatus.allocateStatus === 'NOA') || (stockStatus.allocateStatus === 'NOT')) ? stockStatus.allocateStatus : 'ALL';
                                return eahcCb();
                            }

                            //console.log('allocated', allocatedOnRow);

                            if (!allocatedOnRow) {
                                // stockStatus.allocateStatus = stockStatus.allocateStatus || 'NOA';
                                stockStatus.allocateStatus = ((stockStatus.allocateStatus === 'NOA') || (stockStatus.allocateStatus === 'ALL')) ? 'NOA' : 'NOT';
                                return eahcCb();
                            }

                            if (allocatedOnRow !== elem.qty) { // Before <
                                stockStatus.allocateStatus = 'NOA';
                                return eahcCb();
                            }


                            if (!stockStatus.allocateStatus || stockStatus.allocateStatus == 'ALL') {
                                stockStatus.allocateStatus = 'ALL';
                                return eahcCb();
                            }

                            stockStatus.allocateStatus = 'NOA';
                            return eahcCb();

                        });
                    });

                },
                function(err) {
                    if (err)
                        return cb(err);

                    cb(null, stockStatus);

                });
        } else {
            stockStatus.fulfillStatus = 'NOR';
            stockStatus.allocateStatus = 'NOR';
            stockStatus.shippingStatus = 'NOR';

            cb(null, stockStatus);
        }

    }

    async.waterfall([
        function(wCb) {
            const Order = exports.Schema.Order;
            // Get Type ONLY CustomerOrder AND SupplierOrder type

            Order.findById(data.order._id, "_type", function(err, doc) {
                if (err)
                    return wCb(err);

                if (!doc)
                    return wCb(null, null);

                if (doc._type == 'orderCustomer')
                    return wCb(null, exports.Schema.OrderCustomer);

                if (doc._type == 'orderSupplier')
                    return wCb(null, exports.Schema.OrderSupplier);

                return wCb(null, null);

            });
        },
        function(OrderModel, wCb) {
            if (!OrderModel)
                return wCb();

            OrderRows.find({
                    order: data.order._id, //orderId
                    product: {
                        $ne: null
                    }
                })
                .populate({
                    path: "product",
                    select: "directCost info",
                    populate: {
                        path: "info.productType"
                    },
                })
                .populate('order', 'Status')
                .exec(function(err, docs) {
                    if (err)
                        return wCb(err);

                    getAvailableForRows(docs, function(err, status) {
                        if (err)
                            return wCb(err);

                        OrderModel.findByIdAndUpdate(data.order._id, {
                            status: status
                        }, {
                            new: true
                        }, function(err, el) {
                            if (err)
                                return wCb(err);

                            //console.log(status, el.status);

                            console.log('Status updated');
                            //Force reload order
                            //Force reload product

                            setTimeout2('notify:controllerAngular', function() {
                                F.emit('notify:controllerAngular', {
                                    userId: null,
                                    route: 'order',
                                    _id: el._id.toString(),
                                    //message: "Commande " + el.ref + ' modifie.'
                                });
                            }, 500);

                            wCb();
                        });
                    });

                });
        }
    ], function(err) {
        if (err)
            return console.log(err);
    });
});

F.on('order:sendDelivery', function(data) {
    var userId = data.userId;
    //const OrderRows = MODEL('orderRows').Schema;
    var ObjectId = MODULE('utils').ObjectId;

    const OrderModel = exports.Schema.OrderCustomer;
    const DeliveryModel = exports.Schema.GoodsOutNote;

    //console.log(data);
    console.log("Update emit order sendFirstDelivery", data);
    OrderModel.findOne({
        _id: data.order._id,
        isremoved: {
            $ne: true
        },
        Status: "PROCESSING"
    }, function(err, order) {
        if (err || !order)
            return;

        var object = order.toObject();

        DeliveryModel.findOne({
            order: order._id
        }, function(err, delivery) {
            if (err || delivery)
                return; //already exist

            var id = object._id;
            object.order = object._id;
            delete object._id;
            delete object.Status;
            delete object.latex;
            delete object.datec;
            delete object.datel;
            delete object.createdAt;
            delete object.updatedAt;
            delete object.ref;
            delete object.history;
            delete object._type;
            delete object.status;

            delivery = new DeliveryModel(object);

            delivery.editedBy = userId;
            delivery.createdBy = userId;

            //return console.log(delivery);
            delivery.save(function(err, doc) {
                if (err)
                    return console.log(err);

                F.emit('order:recalculateStatus', {
                    userId: userId,
                    order: {
                        _id: order._id.toString()
                    }
                });
            });
        });
    });
});

F.on('order:update', function(data) {

    //console.log(data);
    console.log("Update emit order !", data);
});